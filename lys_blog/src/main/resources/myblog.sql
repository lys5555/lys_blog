/*
SQLyog Ultimate v12.09 (64 bit)
MySQL - 5.5.40 : Database - myblog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`myblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `myblog`;

/*Table structure for table `t_blog` */

DROP TABLE IF EXISTS `t_blog`;

CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL,
  `commentabled` bit(1) NOT NULL,
  `content` longtext,
  `create_time` datetime DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `first_picture` varchar(255) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `published` bit(1) NOT NULL,
  `recommend` bit(1) NOT NULL,
  `share_statement` bit(1) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `views` int(11) DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  `comment_count` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`) USING BTREE,
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`),
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_blog` */

insert  into `t_blog`(`id`,`appreciation`,`commentabled`,`content`,`create_time`,`description`,`first_picture`,`flag`,`published`,`recommend`,`share_statement`,`title`,`update_time`,`views`,`type_id`,`user_id`,`comment_count`) values (12,'','','一、数组Array和集合的区别\r\n1、数组是大小固定的，并且同一个数组只能存放类型一样的数据（基本类型/引用类型）\r\n\r\n2、JAVA集合可以存储和操作数目不固定的一组数据。\r\n\r\n3、若程序时不知道究竟需要多少对象，需要在空间不足时自动扩增容量，则需要使用容器类库，array不适用。　\r\n\r\n注：使用相应的toArray()和Arrays.asList()方法可以相互转换。\r\n\r\n二、Java集合\r\n集合类存放于Java.util包中。\r\n\r\n集合类存放的都是对象的引用，而非对象本身，出于表达上的便利，我们称集合中的对象就是指集合中对象的引用。\r\n\r\n集合类型主要有三种：set（集）、list（列表）、map（映射）。\r\n\r\n\r\n\r\n三、Collection接口\r\nCollection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素。Java SDK提供的类都是继承自Collection的“子接口”如List和Set。\r\n\r\n如何遍历Collection中的每一个元素？不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素。典型的用法如下：\r\n\r\nIterator it = collection.iterator(); // 获得一个迭代子\r\nwhile(it.hasNext()) {\r\n　　Object obj = it.next(); // 得到下一个元素\r\n}\r\n由Collection接口派生的两个接口是List和Set。\r\n\r\n四、Set\r\nSet接口同样是Collection接口的一个子接口，Set不包含重复的元素。\r\n\r\nHashSet：使用hashmap的一个集的实现。虽然集定义成无序，但必须存在某种方法能高效地找到一个对象。使用一个hashmap对象实现集的存储和检索操作时在固定时间内实现的。\r\n\r\nTreeSet：在集中以升序对对象排序的集的实现。这意味着从一个TreeSet对象获得第一个迭代器将按升序提供对象。TreeSet类使用了一个TreeMap。\r\n\r\n为优化hashset空间的使用，可以调优初始容量和负载因子。TreeSet 不包含调优选项，因为树总是平衡的，保证了插入、删除、查询的性能的高效。\r\n\r\n当您要从集合中以有序的方式抽取元素时，TreeSet实现会有用处。为了能顺利进行，添加到TreeSet的元素必须是可排序的。　\r\n\r\nimport java.util.*;\r\npublic class SetExample {\r\n      public static void main(String args[]) {\r\n          Set set = new HashSet();\r\n          set.add(\"Bernadine\");\r\n          set.add(\"Elizabeth\");\r\n          set.add(\"Gene\");\r\n          set.add(\"Elizabeth\");\r\n          set.add(\"Clara\");\r\n          System.out.println(set);\r\n \r\n          Set sortedSet = new TreeSet(set);\r\n          System.out.println(sortedSet);\r\n      }\r\n}\r\n五、List\r\nList接口继承了Collection接口，定义一个允许重复项的有序集合。该接口不但能够对列表的一部分进行处理，还添加了面向位置的操作。\r\n\r\n实际上有两种list：一种是基本的ArrayList，其优点在于随机访问元素，另一种是更强大的LinkedList，它并不是快速随机访问设计的，而是具有更通用的方法。\r\n\r\nList : 次序是List最重要的特点：它保证维护元素特定的顺序。\r\nArrayList : 由数组实现的List。允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。\r\nLinkedList : 对顺序访问进行了优化，向List中间插入与删除的开销并不大，随机访问则相对较慢。还具有下列方法：addFirst(), addLast(), getFirst(), getLast(), removeFirst() 和 removeLast(), 这些方法 (没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。\r\nVector：实现一个类似数组一样的表，自动增加容量来容纳你所需的元素。使用下标存储和检索对象就象在一个标准的数组中一样。你也可以用一个迭代器从一个Vector中检索对象Vector是唯一的同步容器类!!\r\nstack：这个类从vector派生而来，并增加了方法实现栈，一种后进先出的存储结构。\r\nList的用法示例：\r\n\r\npackage collection;\r\n \r\nimport java.util.*;\r\n \r\npublic class SetExample {\r\n    public static void main(String[] args) {\r\n        List linkedList = new LinkedList();\r\n        for (int i = 0; i <= 5; i++) {\r\n            linkedList.add(\"a\"+i);\r\n        }\r\n        System.out.println(linkedList);\r\n        linkedList.add(3,\"a100\");\r\n        System.out.println(linkedList);\r\n        linkedList.set(6,\"a200\");\r\n        System.out.println(linkedList);\r\n        System.out.println(linkedList.get(2));\r\n        System.out.println(linkedList.indexOf(\"a3\"));\r\n        linkedList.remove(1);\r\n        System.out.println(linkedList);\r\n    }\r\n}\r\n\r\n\r\n六、list和set对比\r\nSet子接口:无序，不允许重复，检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。\r\nList子接口:有序，可以有重复元素，和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。\r\n\r\nSet和List具体子类：\r\n    Set\r\n     |————HashSet：以哈希表的形式存放元素，插入删除速度很快。\r\n\r\n    List\r\n     |————ArrayList：动态数组\r\n     |————LinkedList：链表、队列、堆栈。\r\n\r\n七、map\r\n1、map接口不是Collection接口的继承。\r\n不重复的键到值的映射。\r\n\r\n2、Map.Entry 接口\r\nmap的entrySet()方法返回一个实现map.entry接口的对象集合。集合中每个对象都是底层map中一个特定的键值对。\r\n\r\n3、HashMap 类和 TreeMap 类\r\n在map中插入、删除和定位元素，HashMap是最好的选择。但如果您要按顺序遍历键，那么TreeMap 会更好。根据集合大小，先把元素添加HashMap，再把这种映射转换成一个用于有序键遍历的TreeMap 可能更快。\r\n\r\n为了优化hashmap空间的使用，您可以调优初始容量和负载因子。这个treeMap没有调优选项，因为该树总处于平衡状态。\r\n\r\nhashtable：实现一个映象，所有的键必须非空。为了能高效的工作，定义键的类必须实现hashcode()方法和equal()方法。这个类时前面Java实现的一个继承，并且通常能在实现映象的其它类中更好地使用。\r\nhashmap：实现一个映象，运行存储空对象，而且允许键是空（由于键必须是唯一的，当然只能有一个空）。\r\nWeakHashMap：如果有一个键对于一个对象而言不再被引用，键将被舍弃，WeakHashMap在具有大量数据时使用。\r\nTreeMap： 实现这样一个映象，对象是按键升序排列的。\r\n4、map的使用示例\r\n以下程序演示了具体map类的使用。该程序对自命令行传递的词进行频率计数。hashmap起初用于数据存储。后来，映射被转换为TreeMap以显示有序的键列列表。\r\n\r\npackage collection;\r\n \r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.TreeMap;\r\n \r\npublic class MapExample {\r\n    public static void main(String[] args) {\r\n        String[] array = {\"a\",\"b\",\"c\",\"d\",\"e\"};\r\n        Map map = new HashMap();\r\n        Integer ONE = new Integer(1);\r\n        for (int i=0, n=array.length; i<n; i++) {\r\n            String key = array[i];\r\n            int frequency = i+1;\r\n            map.put(key, frequency);\r\n        }\r\n        System.out.println(map);\r\n        Map sortedMap = new TreeMap(map);\r\n        System.out.println(sortedMap);\r\n        //hashmap的同步\r\n        Map map1 = Collections.synchronizedMap(map);\r\n        System.out.println(map1);\r\n    }\r\n}\r\n5、控制台输出\r\n\r\n\r\n八、HashMap、Hashtable、ConcurrentHashMap的原理与区别\r\n1、HashTable\r\n底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化\r\n初始size为11，扩容：newsize = olesize*2+1\r\n计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length\r\n2、HashMap\r\n（1）HashMap简介\r\n\r\n底层数组+链表实现，可以存储null键和null值，线程不安全\r\n初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂\r\n扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入\r\n插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）\r\n当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀\r\n计算index方法：index = hash & (tab.length – 1)\r\n（2）HashMap加载因子\r\n\r\n 哈希冲突：若干Key的哈希值按数组大小取模后，如果落在同一个数组下标上，将组成一条Entry链，对Key的查找需要遍历Entry链上的每个元素执行equals()比较。\r\n加载因子：为了降低哈希冲突的概率，默认当HashMap中的键值对达到数组大小的75%时，即会触发扩容。因此，如果预估容量是100，即需要设定100/0.75＝134的数组大小。\r\n空间换时间：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突的概率。\r\n（3）HashMap容量\r\n\r\nHashMap和Hashtable都是用hash算法来决定其元素的存储，因此HashMap和Hashtable的hash表包含如下属性：\r\n\r\n容量（capacity）：hash表中桶的数量\r\n初始化容量（initial capacity）：创建hash表时桶的数量，HashMap允许在构造器中指定初始化容量\r\n尺寸（size）：当前hash表中记录的数量\r\n负载因子（load factor）：负载因子等于“size/capacity”。负载因子为0，表示空的hash表，0.5表示半满的散列表，依此类推。轻负载的散列表具有冲突少、适宜插入与查询的特点（但是使用Iterator迭代元素时比较慢）\r\n除此之外，hash表里还有一个“负载极限”，“负载极限”是一个0～1的数值，“负载极限”决定了hash表的最大填满程度。当hash表中的负载因子达到指定的“负载极限”时，hash表会自动成倍地增加容量（桶的数量），并将原有的对象重新分配，放入新的桶内，这称为rehashing。\r\n\r\nHashMap和Hashtable的构造器允许指定一个负载极限，HashMap和Hashtable默认的“负载极限”为0.75，这表明当该hash表的3/4已经被填满时，hash表会发生rehashing。\r\n\r\n“负载极限”的默认值（0.75）是时间和空间成本上的一种折中：\r\n\r\n较高的“负载极限”可以降低hash表所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的操作（HashMap的get()与put()方法都要用到查询）\r\n较低的“负载极限”会提高查询数据的性能，但会增加hash表所占用的内存开销\r\n程序猿可以根据实际情况来调整“负载极限”值。\r\n\r\n3、ConcurrentHashMap\r\n底层采用分段的数组+链表实现，线程安全\r\n通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)\r\nHashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术\r\n有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁\r\n扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容\r\nHashtable和HashMap都实现了Map接口，但是Hashtable的实现是基于Dictionary抽象类的。Java5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。\r\n\r\nHashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞时，对象将会储存在链表的下一个节点中。HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法来找到键值对。如果链表大小超过阈值（TREEIFY_THRESHOLD,8），链表就会被改造为树形结构。\r\n\r\n在HashMap中，null可以作为键，这样的键只有一个，但可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示HashMap中没有该key，也可以表示该key所对应的value为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个key，应该用containsKey()方法来判断。而在Hashtable中，无论是key还是value都不能为null。\r\n\r\nHashtable是线程安全的，它的方法是同步的，可以直接用在多线程环境中。而HashMap则不是线程安全的，在多线程环境中，需要手动实现同步机制。\r\n\r\nHashtable与HashMap另一个区别是HashMap的迭代器（Iterator）是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。\r\n\r\n先看一下简单的类图：\r\n\r\n\r\n\r\n从类图中可以看出来在存储结构中ConcurrentHashMap比HashMap多出了一个类Segment，而Segment是一个可重入锁。\r\n\r\nConcurrentHashMap是使用了锁分段技术来保证线程安全的。\r\n\r\n锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 \r\n\r\nConcurrentHashMap提供了与Hashtable和SynchronizedMap不同的锁机制。Hashtable中采用的锁机制是一次锁住整个hash表，从而在同一时刻只能由一个线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。\r\n\r\nConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。\r\n\r\n九、解惑\r\n1、什么是iterator\r\n对集合的遍历，遍历的时候不建议修改集合。\r\n\r\n2、Iterator与ListIterator有什么区别？\r\nIterator：只能正向遍历集合\r\n\r\nListIerator：继承Iterator，可以双向列表遍历\r\n\r\n3、HashMap与HashTable有什么区别？\r\nHashMap允许空值作为键或值，不同步的，迭代时采用的是快速失败机制\r\n\r\nHashTable不允许空值，同步的\r\n\r\n注：有多线程的可能时，使用hashtable，反之使用hashmap。非线程安全的数据结构能带来更好地性能。\r\n\r\n如果将来有可能需要按顺序获取键值对，hashmap是更好地选择，因为hashmap的一个子类LinkedHashMap。\r\n\r\n如果多线程时使用hashmap，Collections.synchronizedMap（）可以代替，总的来说HashMap更灵活。\r\n\r\n4、在Hashtable上下文中同步是什么意思？\r\n同步意味着在一个时间点只能有一个线程可以改变哈希表，任何线程在执行hashtable的更新操作前需要获取对象锁，其它线程等待锁的释放。\r\n\r\n5、为什么Vector不推荐使用？\r\n使用时ArrayList优先于Vector，Vector是同步的，性能会低一些，如果迭代一个vector，还要加锁，以避免其他线程同一时刻改变集合，加锁效率更慢。\r\n\r\n \r\n————————————————\r\n版权声明：本文为CSDN博主「GooReey」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/guorui_java/article/details/106716234','2021-04-08 15:05:15','数组Array和集合的区别\r\n1、数组是大小固定的，并且同一个数组只能存放类型一样的数据（基本类型/引用类型）\r\n\r\n2、JAVA集合可以存储和操作数目不固定的一组数据。\r\n\r\n3、若程序时不知道究竟需要多少对象，需要在空间不足时自动扩增容量，则需要使用容器类库，array不适用。　\r\n\r\n注：使用相应的toArray()和Arrays.asList()方法可以相互转换...','https://z3.ax1x.com/2021/04/09/cUlC6J.jpg','','','\0','','Java集合基础知识总结','2021-04-09 12:43:24',2,4,2,0),(13,'','','一、Spring的几大核心功能\r\n\r\n1.IoC/DI：控制反转/依赖注入\r\n\r\n2.AOP：面向切面编程\r\n\r\n3.声明式事务\r\n\r\n \r\n\r\n二、IoC\r\n\r\n1.中文名称：控制反转\r\n\r\n2.英文名称:(Inversion of Control)\r\n\r\n3.IoC是什么：\r\n\r\n（1）IoC：指原先有程序员主动new实例化对象的事情，转交给Spring负责\r\n\r\n（2）控制反转中的控制：指控制类的对象\r\n\r\n（3）控制反转中的反转：指交给Spring控制\r\n\r\n（4）IoC最大的作用：解耦，程序员不需要管理对象，解除了管理对象与程序员之间的耦合\r\n\r\n \r\n\r\n三、Spring创建对象的三种方式\r\n\r\n1.通过构造方法创建\r\n\r\n1.1 无参构造创建:默认情况.\r\n1.2 有参构造创建:需要明确配置\r\n1.2.1 需要在类中提供有参构造方法\r\n1.2.2 在 applicationContext.xml 中设置调用哪个构造方法创建\r\n对象\r\n1.2.2.1 如果设定的条件匹配多个构造方法执行最后的构\r\n造方法\r\n1.2.2.2index: 参数的索引,从 0 开始\r\n1.2.2.3name: 参数名\r\n1.2.2.4type:类型(区分开关键字和封装类 int 和 Integer)\r\n\r\n<bean id=\"peo\" class=\"com.bjsxt.pojo.People\">\r\n<!-- ref 引用另一个 bean value 基本数据类型或 String 等 --> <constructor-arg index=\"0\" name=\"id\" type=\"int\" value=\"123\"></constructor-arg> <constructor-arg index=\"1\" name=\"name\"\r\ntype=\"java.lang.String\" value=\" 张 三 \"></constructor-arg> </bean>\r\n\r\n2.实例工厂\r\n\r\n2.1 工厂设计模式:帮助创建类对象.一个工厂可以生产多个对象.\r\n2.2 实例工厂:需要先创建工厂,才能生产对象\r\n2.3 实现步骤:\r\n2.3.1 必须要有一个实例工厂 public class PeopleFactory { public People newInstance(){\r\nreturn new People(1,\"测试\");\r\n}\r\n}\r\n2.3.2 在 applicationContext.xml 中配置工厂对象和需要创建的\r\n对象\r\n<bean id=\"factory\" class=\"com.bjsxt.pojo.PeopleFactory\"></bean> <bean id=\"peo1\" factory-bean=\"factory\" factory-method=\"newInstance\"></bean>\r\n\r\n3.静态工厂\r\n\r\n3.1 不需要创建工厂,快速创建对象.\r\n3.2 实现步骤\r\n3.2.1 编写一个静态工厂(在方法上添加 static)\r\npublic class PeopleFactory { public static People newInstance(){\r\nreturn new People(1,\"测试\");\r\n}\r\n}\r\n3.2.2 在 applicationContext.xml 中 <bean id=\"peo2\" class=\"com.bjsxt.pojo.PeopleFactory\" factory-method=\"newInstance\"></bean>\r\n\r\n \r\n\r\n四、如何给Bean的属性赋值（注入）\r\n\r\n1.通过该构造方法赋值\r\n\r\n2.设置注入（通过set方法）\r\n\r\n2.1 如果属性是基本数据类型或 String 等简单\r\n<bean id=\"peo\" class=\"com.bjsxt.pojo.People\"> <property name=\"id\" value=\"222\"></property>\r\n<property name=\"name\" value=\" 张 三 \"></property> </bean>\r\n2.1.1 等效于 <bean id=\"peo\" class=\"com.bjsxt.pojo.People\"> <property name=\"id\"> <value>456</value> </property> <property name=\"name\"> <value>zhangsan</value> </property> </bean>\r\n2.2 如果属性是 Set<?> <property name=\"sets\"> <set> <value>1</value>\r\n<value>2</value> <value>3</value> <value>4</value> </set> </property>\r\n2.3 如果属性是 List<?> <property name=\"list\"> <list> <value>1</value> <value>2</value> <value>3</value> </list> </property>\r\n2.3.1 如果 list 中就只有一个值\r\n<property name=\"list\" value=\"1\"> </property>\r\n2.4 如果属性是数组\r\n2.4.1 如果数组中就只有一个值,可以直接通过 value 属性赋值 <property name=\"strs\" > <array> <value>1</value> <value>2</value>\r\n<value>3</value> </array> </property>\r\n2.5 如果属性是 map <property name=\"map\"> <map> <entry key=\"a\" value=\"b\" > </entry> <entry key=\"c\" value=\"d\" > </entry> </map> </property>\r\n2.6 如果属性 Properties 类型\r\n<property name=\"demo\"> <props> <prop key=\"key\">value</prop> <prop key=\"key1\">value1</prop> </props> </property>\r\n\r\n \r\n\r\n五、DI\r\n\r\n1.DI:中文名称:依赖注入\r\n2. 英文名称((Dependency Injection)\r\n\r\n3.DI是什么？\r\n\r\n（1）DI和IoC是一样的\r\n\r\n（2）当一个类（A）需要依赖另一个类（B）对象时，将类B赋值给类A的过程就叫做依赖注入\r\n\r\n4.代码体现：\r\n\r\n<bean id=\"peo\" class=\"com.bjsxt.pojo.People\"> <property name=\"desk\" ref=\"desk\"></property> </bean>\r\n<bean id=\"desk\" class=\"com.bjsxt.pojo.Desk\"> <property name=\"id\" value=\"1\"></property> <property name=\"price\" value=\"12\"></property> </bean>\r\n\r\n \r\n————————————————\r\n版权声明：本文为CSDN博主「我见青山多抚媚」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/qq_39086296/article/details/90198995','2021-04-08 15:17:05','Spring的几大核心功能\r\n\r\n1.IoC/DI：控制反转/依赖注入\r\n\r\n2.AOP：面向切面编程\r\n\r\n3.声明式事务\r\n\r\n IoC\r\n\r\n1.中文名称：控制反转\r\n\r\n2.英文名称:(Inversion of Control)\r\n3.IoC是...','https://z3.ax1x.com/2021/04/09/cUQgOA.jpg','','','\0','','Spring框架重要知识点','2021-04-09 12:40:01',2,10,2,0),(14,'','','Web应用执行流程\r\nJavaEE概念、技术（了解）\r\n通过实现Servlet接口，编写代码（写类，实现接口，重写5个接口：初始化等）\r\ninit destroy service getServletConfig getServletInfo\r\n\r\nServlet接口和HttpServlet之间的关系\r\nHttpServlet继承GenericServlet GenericServlet继承Servlet\r\n\r\nServlet中请求和响应的用法（request用法，写程序，）\r\nrequest\r\nresponse\r\n\r\n转发请求和重定向跳转的关系（本质，关系）\r\n请求转发：一次请求\r\n请求重定向：两次请求\r\n速度:请求重定向<请求转发\r\n参数：请求转发可共享参数\r\n请求重定向不可共享参数\r\n\r\nServlet的生命周期\r\n客户端向Servlet容器中发送请求，Servlet容器解析请求后创建Servlet实例，调用init方法，调用service方法\r\n输出相应信息，返回响应，Servlet容器关闭后，调用destroy方法。\r\n\r\nservletConfig和ServletContext的用法\r\nset/getAttribute应用于request\r\ngetParameter应用于客户端页面与Servlet之间\r\ngetServletConfig 应用于一个Servlet对象的初始化参数\r\ngetServletContext应用于整个Web应用范围的初始化参数\r\n\r\n注解配置Servlet\r\nurl-pattern\r\n\r\n会话的实现过程（流程）\r\n当服务器接收到一个来自客户端的请求时，服务器初始化一个会话并分配给该会话一个唯一的标识符\r\n在以后的请求中，客户端必须将唯一标识符包含在请求中，服务器根据此表示符将请求与对应的会话联系起来\r\n\r\nCookie的使用（怎么得到Cookie，怎么把Cookie发到客户端 代码）\r\n得到Cookie Cookie c = new Cookie(“username”,“a1234”)；\r\n发送Cookie response.addCookie©;\r\n\r\n隐藏域和重写URL（了解）\r\nSession的机制原理（会用话描述）\r\n在Servlet中进行会话管理可以使用HTTPServlet的getSession方法取得HTTPSession对象\r\n通过设置获取服务器端Session对象的属性来保留请求之间的相关信息\r\n\r\nSession的具体使用\r\n\r\nHttpSession session = req.getSession();\r\nsession.setAttribute(“username”,username);\r\nSession的关闭（关闭的方法：超时）\r\n关闭Session：session.invalidate();\r\n通常客户端不提供结束回话的通知，而是Servlet容器在用户处于一段非活动期后就会自动的使会话失效–这段时间称为会话的超时期\r\nSession对象失效：当用户超出制定会话期时间处于非活动状态时，会话自动结束\r\nsetMaxInactiveInterval()设置会话的超时期\r\n默认关闭浏览器Cookie消失\r\n\r\n8个监听器的使用，各个监听器之间的区别（简答填空）\r\nServletContextListener\r\nServletContextAttributeListener\r\nHttpSessionListener\r\nHttpSessionAttributeListener\r\nHttpSessionActionListener\r\nHttpSessionBindingListener\r\nServletRequestListener\r\nServletRequestAttributeListener\r\n\r\n过滤器的功能\r\n第一：分析请求，将请求发送给指定的资源或自己创建一个响应返回\r\n第二：在请求到达服务器端前处理请求，设置请求信息，将请求封装成符合规则的对象\r\n第三：在响应到达客户端前处理响应，将响应封装成符合规则的对象\r\n\r\n编写过滤器（代码）\r\n\r\n注册过滤器\r\nnet.onest.CharsetFilter\r\n\r\n\r\n\r\n\r\n过滤器链的执行过程\r\nWeb容器加载的顺序：web.xml文件中配置的Filter的倒序\r\n拦截执行顺序：web.xml文件中配置的Filter的正序\r\n销毁顺序：web.xml文件中配置的Filter的倒序\r\n\r\nJSP和Servlet的关系\r\n一个JSP文件第一此被请求时，JSP引擎把该文件转换成为一个servlet\r\nJSP引擎使用javac把转换成的servlet的源文件编译成相应的class文件\r\n对于每一个请求，JSP引擎创建一个新的线程来处理请求\r\n\r\nJSP的生命周期\r\nJSP的声明、表达式、脚本\r\nJSP的page、include、taglib指令\r\nJSP的9个内置对象用法\r\nJSP的4个作用域用法\r\n静态包含和动态包含\r\nuseBean动作和forward动作的用法（选择）\r\nEL的用法（程序题EL用法），EL中的对象、EL的各种运算符、EL的自定义函数（了解）\r\n\r\npublic class StrMethods{\r\npublic static String upper(String x){\r\nreturn x.toUpperCase();\r\n}\r\npublci static int length(String x){\r\nreturn x.lenth;\r\n}\r\n}\r\n\r\n标准标签库中核心标签库的用法\r\njstl.jar提供了标签开发接口类\r\nstandard.jar提供了标签库的实现类\r\n<%@taglib prefix=“c” uri=“http://java.sun.com/jstl/core”%>\r\n<c:catch>捕获异常\r\n<c:out>打印输出\r\n<c:set>设置变量值\r\n<c:remove>删除变量\r\n<c:if>条件判断\r\n<c:foreach>\r\n<c:forToken>循环控制\r\n<c:url>重写URL地址\r\n<c:import>导入资源\r\n<c:redirect>重定向请求\r\ncontains测试输入的字符串是否包含指定的子串\r\nendsWith测试输入的字符串是否以指定的后缀结尾\r\nescapeXml跳过可以作为XML标记的字符\r\nindexOf返回指定字符串在输入字符串中出现的位置\r\njoin将数组中的元素合成一个字符串然后输出\r\nlength返回字符串长度\r\nreplace将输入字符串中指定的位置替换为指定的字符串然后返回\r\nsplit截取字符串（按分隔符）\r\n安全当中的4个认证机制，各自的特点等（填空，选择）\r\n基本认证 摘要认证 客户端认证 表单认证\r\n都是基于用户名密码机制\r\n基本认证：容易建立支持所有的浏览器，但是用户名和密码没有加密\r\n摘要认证：比基本认证安全，但是仅有IE浏览器支持\r\n客户认证;4中认证中最安全的 被所有浏览器支持；需要认证中心颁发的证书，实现和维护具有较高的成本\r\n表单认证：容易建立，支持所有的浏览器，可以定制登录窗体的外观，不安全，用户名密码未加密，只有在Cookie维持会话时才可以使用\r\n\r\nJavaWeb程序的目录结构，路径的映射方式，程序的部署方式\r\n————————————————\r\n版权声明：本文为CSDN博主「冷暖不知」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\r\n原文链接：https://blog.csdn.net/weixin_43759467/article/details/110677529','2021-04-08 15:20:27','Web应用执行流程\r\nJavaEE概念、技术（了解）\r\n通过实现Servlet接口，编写代码（写类，实现接口，重写5个接口：初始化等）\r\ninit destroy service getServletConfig getServletInfo\r\n\r\nServlet接口和HttpServlet之间的关系\r\nHttpServlet继承GenericServlet GenericServlet继承...','https://z3.ax1x.com/2021/04/09/cUQySe.jpg','转载','','\0','','JavaEE基础梳理','2021-04-09 12:41:00',1,4,2,0),(16,'','','# mysq基础\r\n\r\n1. 数据库的基本概念\r\n\r\n\r\n2. MySQL数据库软件\r\n	1. 安装\r\n	2. 卸载\r\n	3. 配置\r\n\r\n3. SQL\r\n\r\n\r\n## 数据库的基本概念\r\n	1. 数据库的英文单词： DataBase 简称 ： DB\r\n	2. 什么数据库？\r\n		* 用于存储和管理数据的仓库。\r\n\r\n	3. 数据库的特点：\r\n		1. 持久化存储数据的。其实数据库就是一个文件系统\r\n		2. 方便存储和管理数据\r\n		3. 使用了统一的方式操作数据库 -- SQL\r\n\r\n	\r\n	4. 常见的数据库软件\r\n		* 参见《MySQL基础.pdf》\r\n\r\n\r\n# MySQL数据库软件\r\n	1. 安装\r\n		* 参见《MySQL基础.pdf》\r\n	2. 卸载\r\n		1. 去mysql的安装目录找到my.ini文件\r\n			* 复制 datadir=\"C:/ProgramData/MySQL/MySQL Server 5.5/Data/\"\r\n		2. 卸载MySQL\r\n		3. 删除C:/ProgramData目录下的MySQL文件夹。\r\n		\r\n	3. 配置\r\n		* MySQL服务启动\r\n			1. 手动。\r\n			2. cmd--> services.msc 打开服务的窗口\r\n			3. 使用管理员打开cmd\r\n				* net start mysql : 启动mysql的服务\r\n				* net stop mysql:关闭mysql服务\r\n		* MySQL登录\r\n			1. mysql -uroot -p密码\r\n			2. mysql -hip -uroot -p连接目标的密码\r\n			3. mysql --host=ip --user=root --password=连接目标的密码\r\n		* MySQL退出\r\n			1. exit\r\n			2. quit\r\n	\r\n		* MySQL目录结构\r\n			1. MySQL安装目录：basedir=\"D:/develop/MySQL/\"\r\n				* 配置文件 my.ini\r\n			2. MySQL数据目录：datadir=\"C:/ProgramData/MySQL/MySQL Server 5.5/Data/\"\r\n				* 几个概念\r\n					* 数据库：文件夹\r\n					* 表：文件\r\n					* 数据：数据\r\n\r\n\r\n\r\n# SQL\r\n\r\n	1.什么是SQL？\r\n		Structured Query Language：结构化查询语言\r\n		其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。\r\n		\r\n	2.SQL通用语法\r\n		1. SQL 语句可以单行或多行书写，以分号结尾。\r\n		2. 可使用空格和缩进来增强语句的可读性。\r\n		3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\r\n		4. 3 种注释\r\n			* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \r\n			* 多行注释: /* 注释 */\r\n		\r\n	3. SQL分类\r\n		1) DDL(Data Definition Language)数据定义语言\r\n			用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\r\n		2) DML(Data Manipulation Language)数据操作语言\r\n			用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\r\n		3) DQL(Data Query Language)数据查询语言\r\n			用来查询数据库中表的记录(数据)。关键字：select, where 等\r\n		4) DCL(Data Control Language)数据控制语言(了解)\r\n			用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\r\n\r\n## DDL:操作数据库、表\r\n\r\n	1. 操作数据库：CRUD\r\n		1. C(Create):创建\r\n			* 创建数据库：\r\n				* create database 数据库名称;\r\n			* 创建数据库，判断不存在，再创建：\r\n				* create database if not exists 数据库名称;\r\n			* 创建数据库，并指定字符集\r\n				* create database 数据库名称 character set 字符集名;\r\n\r\n			* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\r\n				* create database if not exists db4 character set gbk;\r\n		2. R(Retrieve)：查询\r\n			* 查询所有数据库的名称:\r\n				* show databases;\r\n			* 查询某个数据库的字符集:查询某个数据库的创建语句\r\n				* show create database 数据库名称;\r\n		3. U(Update):修改\r\n			* 修改数据库的字符集\r\n				* alter database 数据库名称 character set 字符集名称;\r\n		4. D(Delete):删除\r\n			* 删除数据库\r\n				* drop database 数据库名称;\r\n			* 判断数据库存在，存在再删除\r\n				* drop database if exists 数据库名称;\r\n		5. 使用数据库\r\n			* 查询当前正在使用的数据库名称\r\n				* select database();\r\n			* 使用数据库\r\n				* use 数据库名称;\r\n\r\n\r\n	2. 操作表\r\n		1. C(Create):创建\r\n			1. 语法：\r\n				create table 表名(\r\n					列名1 数据类型1,\r\n					列名2 数据类型2,\r\n					....\r\n					列名n 数据类型n\r\n				);\r\n				* 注意：最后一列，不需要加逗号（,）\r\n				* 数据库类型：\r\n					1. int：整数类型\r\n						* age int,\r\n					2. double:小数类型\r\n						* score double(5,2)\r\n					3. date:日期，只包含年月日，yyyy-MM-dd\r\n					4. datetime:日期，包含年月日时分秒	 yyyy-MM-dd HH:mm:ss\r\n					5. timestamp:时间错类型	包含年月日时分秒	 yyyy-MM-dd HH:mm:ss	\r\n						* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\r\n\r\n					6. varchar：字符串\r\n						* name varchar(20):姓名最大20个字符\r\n						* zhangsan 8个字符  张三 2个字符\r\n				\r\n\r\n			* 创建表\r\n				create table student(\r\n					id int,\r\n					name varchar(32),\r\n					age int ,\r\n					score double(4,1),\r\n					birthday date,\r\n					insert_time timestamp\r\n				);\r\n			* 复制表：\r\n				* create table 表名 like 被复制的表名;	  	\r\n		2. R(Retrieve)：查询\r\n			* 查询某个数据库中所有的表名称\r\n				* show tables;\r\n			* 查询表结构\r\n				* desc 表名;\r\n		3. U(Update):修改\r\n			1. 修改表名\r\n				alter table 表名 rename to 新的表名;\r\n			2. 修改表的字符集\r\n				alter table 表名 character set 字符集名称;\r\n			3. 添加一列\r\n				alter table 表名 add 列名 数据类型;\r\n			4. 修改列名称 类型\r\n				alter table 表名 change 列名 新列别 新数据类型;\r\n				alter table 表名 modify 列名 新数据类型;\r\n			5. 删除列\r\n				alter table 表名 drop 列名;\r\n		4. D(Delete):删除\r\n			* drop table 表名;\r\n			* drop table  if exists 表名 ;\r\n\r\n* 客户端图形化工具：SQLYog\r\n\r\n## DML：增删改表中数据\r\n\r\n	1. 添加数据：\r\n		* 语法：\r\n			* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\r\n		* 注意：\r\n			1. 列名和值要一一对应。\r\n			2. 如果表名后，不定义列名，则默认给所有列添加值\r\n				insert into 表名 values(值1,值2,...值n);\r\n			3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\r\n	2. 删除数据：\r\n		* 语法：\r\n			* delete from 表名 [where 条件]\r\n		* 注意：\r\n			1. 如果不加条件，则删除表中所有记录。\r\n			2. 如果要删除所有记录\r\n				1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\r\n				2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\r\n	3. 修改数据：\r\n		* 语法：\r\n			* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];\r\n\r\n		* 注意：\r\n			1. 如果不加任何条件，则会将表中所有记录全部修改。\r\n\r\n\r\n\r\n## DQL：查询表中的记录\r\n	* select * from 表名;\r\n	\r\n	1. 语法：\r\n		select\r\n			字段列表\r\n		from\r\n			表名列表\r\n		where\r\n			条件列表\r\n		group by\r\n			分组字段\r\n		having\r\n			分组之后的条件\r\n		order by\r\n			排序\r\n		limit\r\n			分页限定\r\n\r\n\r\n	2. 基础查询\r\n		1. 多个字段的查询\r\n			select 字段名1，字段名2... from 表名；\r\n			* 注意：\r\n				* 如果查询所有字段，则可以使用*来替代字段列表。\r\n		2. 去除重复：\r\n			* distinct\r\n		3. 计算列\r\n			* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\r\n			* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\r\n				* 表达式1：哪个字段需要判断是否为null\r\n				* 如果该字段为null后的替换值。\r\n		4. 起别名：\r\n			* as：as也可以省略\r\n			\r\n\r\n	3. 条件查询\r\n		1. where子句后跟条件\r\n		2. 运算符\r\n			* > 、< 、<= 、>= 、= 、<>\r\n			* BETWEEN...AND  \r\n			* IN( 集合) \r\n			* LIKE：模糊查询\r\n				* 占位符：\r\n					* _:单个任意字符\r\n					* %：多个任意字符\r\n			* IS NULL  \r\n			* and  或 &&\r\n			* or  或 || \r\n			* not  或 !\r\n			\r\n				-- 查询年龄大于20岁\r\n\r\n				SELECT * FROM student WHERE age > 20;\r\n				\r\n				SELECT * FROM student WHERE age >= 20;\r\n				\r\n				-- 查询年龄等于20岁\r\n				SELECT * FROM student WHERE age = 20;\r\n				\r\n				-- 查询年龄不等于20岁\r\n				SELECT * FROM student WHERE age != 20;\r\n				SELECT * FROM student WHERE age <> 20;\r\n				\r\n				-- 查询年龄大于等于20 小于等于30\r\n				\r\n				SELECT * FROM student WHERE age >= 20 &&  age <=30;\r\n				SELECT * FROM student WHERE age >= 20 AND  age <=30;\r\n				SELECT * FROM student WHERE age BETWEEN 20 AND 30;\r\n				\r\n				-- 查询年龄22岁，18岁，25岁的信息\r\n				SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\r\n				SELECT * FROM student WHERE age IN (22,18,25);\r\n				\r\n				-- 查询英语成绩为null\r\n				SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断\r\n				\r\n				SELECT * FROM student WHERE english IS NULL;\r\n				\r\n				-- 查询英语成绩不为null\r\n				SELECT * FROM student WHERE english  IS NOT NULL;\r\n	\r\n\r\n\r\n				-- 查询姓马的有哪些？ like\r\n				SELECT * FROM student WHERE NAME LIKE \'马%\';\r\n				-- 查询姓名第二个字是化的人\r\n				\r\n				SELECT * FROM student WHERE NAME LIKE \"_化%\";\r\n				\r\n				-- 查询姓名是3个字的人\r\n				SELECT * FROM student WHERE NAME LIKE \'___\';\r\n				\r\n				\r\n				-- 查询姓名中包含德的人\r\n				SELECT * FROM student WHERE NAME LIKE \'%德%\';\r\n\r\n\r\n\r\n	','2021-04-09 11:59:49','mysq基础\r\n\r\n    数据库的基本概念\r\n\r\n    MySQL数据库软件\r\n        安装\r\n        卸载\r\n        配置\r\n\r\n    SQL\r\n\r\n数据库的基本概念\r\n\r\n    1. 数据库的英文单词： DataBase 简称 ： DB\r\n    2. 什么数据库？\r\n        * 用于存储和管理数据的仓库。\r\n    3. 数据库的特点：\r\n        1. 持久化存储数据的...','https://z3.ax1x.com/2021/04/09/cUl9l4.jpg','','','','','mysql基础笔记','2021-04-09 12:45:22',2,11,2,0),(17,'','','# mysql约束\r\n	\r\n	1. DQL:查询语句\r\n		1. 排序查询\r\n		2. 聚合函数\r\n		3. 分组查询\r\n		4. 分页查询\r\n\r\n	2. 约束\r\n	3. 多表之间的关系\r\n	4. 范式\r\n	5. 数据库的备份和还原\r\n\r\n# DQL:查询语句\r\n	1. 排序查询\r\n		* 语法：order by 子句\r\n			* order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...\r\n\r\n		* 排序方式：\r\n			* ASC：升序，默认的。\r\n			* DESC：降序。\r\n\r\n		* 注意：\r\n			* 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。\r\n\r\n\r\n	2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。\r\n		1. count：计算个数\r\n			1. 一般选择非空的列：主键\r\n			2. count(*)\r\n		2. max：计算最大值\r\n		3. min：计算最小值\r\n		4. sum：计算和\r\n		5. avg：计算平均值\r\n		\r\n\r\n		* 注意：聚合函数的计算，排除null值。\r\n			解决方案：\r\n				1. 选择不包含非空的列进行计算\r\n				2. IFNULL函数\r\n\r\n	3. 分组查询:\r\n		1. 语法：group by 分组字段；\r\n		2. 注意：\r\n			1. 分组之后查询的字段：分组字段、聚合函数\r\n			2. where 和 having 的区别？\r\n				1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来\r\n				2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。\r\n\r\n			-- 按照性别分组。分别查询男、女同学的平均分\r\n\r\n			SELECT sex , AVG(math) FROM student GROUP BY sex;\r\n			\r\n			-- 按照性别分组。分别查询男、女同学的平均分,人数\r\n			\r\n			SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;\r\n			\r\n			--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组\r\n			SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex;\r\n			\r\n			--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人\r\n			SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id) > 2;\r\n			\r\n			SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数 > 2;\r\n\r\n\r\n			\r\n	4. 分页查询\r\n		1. 语法：limit 开始的索引,每页查询的条数;\r\n		2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数\r\n			-- 每页显示3条记录 \r\n\r\n			SELECT * FROM student LIMIT 0,3; -- 第1页\r\n			\r\n			SELECT * FROM student LIMIT 3,3; -- 第2页\r\n			\r\n			SELECT * FROM student LIMIT 6,3; -- 第3页\r\n\r\n		3. limit 是一个MySQL\"方言\"\r\n\r\n\r\n## 约束\r\n	* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。	\r\n	* 分类：\r\n		1. 主键约束：primary key\r\n		2. 非空约束：not null\r\n		3. 唯一约束：unique\r\n		4. 外键约束：foreign key\r\n\r\n	* 非空约束：not null，值不能为null\r\n		1. 创建表时添加约束\r\n			CREATE TABLE stu(\r\n				id INT,\r\n				NAME VARCHAR(20) NOT NULL -- name为非空\r\n			);\r\n		2. 创建表完后，添加非空约束\r\n			ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;\r\n\r\n		3. 删除name的非空约束\r\n			ALTER TABLE stu MODIFY NAME VARCHAR(20);\r\n	\r\n	\r\n	* 唯一约束：unique，值不能重复\r\n		1. 创建表时，添加唯一约束\r\n			CREATE TABLE stu(\r\n				id INT,\r\n				phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束\r\n			\r\n			);\r\n			* 注意mysql中，唯一约束限定的列的值可以有多个null\r\n		\r\n		\r\n		2. 删除唯一约束\r\n		\r\n			ALTER TABLE stu DROP INDEX phone_number;\r\n		\r\n		3. 在创建表后，添加唯一约束\r\n			ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;\r\n	\r\n	* 主键约束：primary key。\r\n		1. 注意：\r\n			1. 含义：非空且唯一\r\n			2. 一张表只能有一个字段为主键\r\n			3. 主键就是表中记录的唯一标识\r\n\r\n		2. 在创建表时，添加主键约束\r\n			create table stu(\r\n				id int primary key,-- 给id添加主键约束\r\n				name varchar(20)\r\n			);\r\n\r\n		3. 删除主键\r\n			-- 错误 alter table stu modify id int ;\r\n			ALTER TABLE stu DROP PRIMARY KEY;\r\n\r\n		4. 创建完表后，添加主键\r\n			ALTER TABLE stu MODIFY id INT PRIMARY KEY;\r\n\r\n		5. 自动增长：\r\n			1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长\r\n\r\n			2. 在创建表时，添加主键约束，并且完成主键自增长\r\n			create table stu(\r\n				id int primary key auto_increment,-- 给id添加主键约束\r\n				name varchar(20)\r\n			);\r\n\r\n			\r\n			3. 删除自动增长\r\n			ALTER TABLE stu MODIFY id INT;\r\n			4. 添加自动增长\r\n			ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;\r\n\r\n\r\n	* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。\r\n		1. 在创建表时，可以添加外键\r\n			* 语法：\r\n				create table 表名(\r\n					....\r\n					外键列\r\n					constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\r\n				);\r\n\r\n		2. 删除外键\r\n			ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\r\n\r\n		3. 创建表之后，添加外键\r\n			ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);\r\n		\r\n		\r\n		4. 级联操作\r\n			1. 添加级联操作\r\n				语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 \r\n						FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;\r\n			2. 分类：\r\n				1. 级联更新：ON UPDATE CASCADE \r\n				2. 级联删除：ON DELETE CASCADE \r\n	\r\n\r\n## 数据库的设计\r\n\r\n	1. 多表之间的关系\r\n		1. 分类：\r\n			1. 一对一(了解)：\r\n				* 如：人和身份证\r\n				* 分析：一个人只有一个身份证，一个身份证只能对应一个人\r\n			2. 一对多(多对一)：\r\n				* 如：部门和员工\r\n				* 分析：一个部门有多个员工，一个员工只能对应一个部门\r\n			3. 多对多：\r\n				* 如：学生和课程\r\n				* 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择\r\n		2. 实现关系：\r\n			1. 一对多(多对一)：\r\n				* 如：部门和员工\r\n				* 实现方式：在多的一方建立外键，指向一的一方的主键。\r\n			2. 多对多：\r\n				* 如：学生和课程\r\n				* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键\r\n			3. 一对一(了解)：\r\n				* 如：人和身份证\r\n				* 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。\r\n\r\n		3. 案例\r\n			-- 创建旅游线路分类表 tab_category\r\n			-- cid 旅游线路分类主键，自动增长\r\n			-- cname 旅游线路分类名称非空，唯一，字符串 100\r\n			CREATE TABLE tab_category (\r\n				cid INT PRIMARY KEY AUTO_INCREMENT,\r\n				cname VARCHAR(100) NOT NULL UNIQUE\r\n			);\r\n			\r\n			-- 创建旅游线路表 tab_route\r\n			/*\r\n			rid 旅游线路主键，自动增长\r\n			rname 旅游线路名称非空，唯一，字符串 100\r\n			price 价格\r\n			rdate 上架时间，日期类型\r\n			cid 外键，所属分类\r\n			*/\r\n			CREATE TABLE tab_route(\r\n				rid INT PRIMARY KEY AUTO_INCREMENT,\r\n				rname VARCHAR(100) NOT NULL UNIQUE,\r\n				price DOUBLE,\r\n				rdate DATE,\r\n				cid INT,\r\n				FOREIGN KEY (cid) REFERENCES tab_category(cid)\r\n			);\r\n			\r\n			/*创建用户表 tab_user\r\n			uid 用户主键，自增长\r\n			username 用户名长度 100，唯一，非空\r\n			password 密码长度 30，非空\r\n			name 真实姓名长度 100\r\n			birthday 生日\r\n			sex 性别，定长字符串 1\r\n			telephone 手机号，字符串 11\r\n			email 邮箱，字符串长度 100\r\n			*/\r\n			CREATE TABLE tab_user (\r\n				uid INT PRIMARY KEY AUTO_INCREMENT,\r\n				username VARCHAR(100) UNIQUE NOT NULL,\r\n				PASSWORD VARCHAR(30) NOT NULL,\r\n				NAME VARCHAR(100),\r\n				birthday DATE,\r\n				sex CHAR(1) DEFAULT \'男\',\r\n				telephone VARCHAR(11),\r\n				email VARCHAR(100)\r\n			);\r\n			\r\n			/*\r\n			创建收藏表 tab_favorite\r\n			rid 旅游线路 id，外键\r\n			date 收藏时间\r\n			uid 用户 id，外键\r\n			rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次\r\n			*/\r\n			CREATE TABLE tab_favorite (\r\n				rid INT, -- 线路id\r\n				DATE DATETIME,\r\n				uid INT, -- 用户id\r\n				-- 创建复合主键\r\n				PRIMARY KEY(rid,uid), -- 联合主键\r\n				FOREIGN KEY (rid) REFERENCES tab_route(rid),\r\n				FOREIGN KEY(uid) REFERENCES tab_user(uid)\r\n			);\r\n\r\n		\r\n	2. 数据库设计的范式\r\n		* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求\r\n\r\n			设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\r\n			目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\r\n\r\n		* 分类：\r\n			1. 第一范式（1NF）：每一列都是不可分割的原子数据项\r\n			2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）\r\n				* 几个概念：\r\n					1. 函数依赖：A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A\r\n						例如：学号-->姓名。  （学号，课程名称） --> 分数\r\n					2. 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。\r\n						例如：（学号，课程名称） --> 分数\r\n					3. 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。\r\n						例如：（学号，课程名称） -- > 姓名\r\n					4. 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A\r\n						例如：学号-->系名，系名-->系主任\r\n					5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码\r\n						例如：该表中码为：（学号，课程名称）\r\n						* 主属性：码属性组中的所有属性\r\n						* 非主属性：除过码属性组的属性\r\n						\r\n			3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）\r\n\r\n\r\n## 数据库的备份和还原\r\n\r\n	1. 命令行：\r\n		* 语法：\r\n			* 备份： mysqldump -u用户名 -p密码 数据库名称 > 保存的路径\r\n			* 还原：\r\n				1. 登录数据库\r\n				2. 创建数据库\r\n				3. 使用数据库\r\n				4. 执行文件。source 文件路径\r\n	2. 图形化工具：','2021-04-09 12:23:53','mysql约束\r\n	\r\n	1. DQL:查询语句\r\n		1. 排序查询\r\n		2. 聚合函数\r\n		3. 分组查询\r\n		4. 分页查询\r\n\r\n	2. 约束\r\n	3. 多表之间的关系\r\n	4. 范式\r\n	5. 数据库的备份和还原\r\n\r\n# DQL:查询语句\r\n	1. 排序查询\r\n		* 语法：order by 子句\r\n			* order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...\r\n	','https://z3.ax1x.com/2021/04/09/cUQIfS.jpg','','','','','mysql约束笔记','2021-04-09 12:45:39',4,11,2,0),(18,'','','# mysql多表&事务\r\n\r\n	1. 多表查询\r\n\r\n	2. 事务\r\n\r\n	3. DCL\r\n\r\n\r\n## 多表查询：\r\n	* 查询语法：\r\n		select\r\n			列名列表\r\n		from\r\n			表名列表\r\n		where....\r\n	* 准备sql\r\n		# 创建部门表\r\n		CREATE TABLE dept(\r\n			id INT PRIMARY KEY AUTO_INCREMENT,\r\n			NAME VARCHAR(20)\r\n		);\r\n		INSERT INTO dept (NAME) VALUES (\'开发部\'),(\'市场部\'),(\'财务部\');\r\n		# 创建员工表\r\n		CREATE TABLE emp (\r\n			id INT PRIMARY KEY AUTO_INCREMENT,\r\n			NAME VARCHAR(10),\r\n			gender CHAR(1), -- 性别\r\n			salary DOUBLE, -- 工资\r\n			join_date DATE, -- 入职日期\r\n			dept_id INT,\r\n			FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)\r\n		);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'孙悟空\',\'男\',7200,\'2013-02-24\',1);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'猪八戒\',\'男\',3600,\'2010-12-02\',2);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'唐僧\',\'男\',9000,\'2008-08-08\',2);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'白骨精\',\'女\',5000,\'2015-10-07\',3);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'蜘蛛精\',\'女\',4500,\'2011-03-14\',1);\r\n	* 笛卡尔积：\r\n		* 有两个集合A,B .取这两个集合的所有组成情况。\r\n		* 要完成多表查询，需要消除无用的数据\r\n	* 多表查询的分类：\r\n		1. 内连接查询：\r\n			1. 隐式内连接：使用where条件消除无用数据\r\n				* 例子：\r\n				-- 查询所有员工信息和对应的部门信息\r\n\r\n				SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\r\n				\r\n				-- 查询员工表的名称，性别。部门表的名称\r\n				SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\r\n				\r\n				SELECT \r\n					t1.name, -- 员工表的姓名\r\n					t1.gender,-- 员工表的性别\r\n					t2.name -- 部门表的名称\r\n				FROM\r\n					emp t1,\r\n					dept t2\r\n				WHERE \r\n					t1.`dept_id` = t2.`id`;\r\n\r\n	\r\n			2. 显式内连接：\r\n				* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件\r\n				* 例如：\r\n					* SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;	\r\n					* SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;	\r\n\r\n			3. 内连接查询：\r\n				1. 从哪些表中查询数据\r\n				2. 条件是什么\r\n				3. 查询哪些字段\r\n		2. 外链接查询：\r\n			1. 左外连接：\r\n				* 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；\r\n				* 查询的是左表所有数据以及其交集部分。\r\n				* 例子：\r\n					-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称\r\n					SELECT 	t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;\r\n			2. 右外连接：\r\n				* 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；\r\n				* 查询的是右表所有数据以及其交集部分。\r\n				* 例子：\r\n					SELECT 	* FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;\r\n		3. 子查询：\r\n			* 概念：查询中嵌套查询，称嵌套查询为子查询。\r\n				-- 查询工资最高的员工信息\r\n				-- 1 查询最高的工资是多少 9000\r\n				SELECT MAX(salary) FROM emp;\r\n				\r\n				-- 2 查询员工信息，并且工资等于9000的\r\n				SELECT * FROM emp WHERE emp.`salary` = 9000;\r\n				\r\n				-- 一条sql就完成这个操作。子查询\r\n				SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);\r\n\r\n			* 子查询不同情况\r\n				1. 子查询的结果是单行单列的：\r\n					* 子查询可以作为条件，使用运算符去判断。 运算符： > >= < <= =\r\n					* \r\n					-- 查询员工工资小于平均工资的人\r\n					SELECT * FROM emp WHERE emp.salary < (SELECT AVG(salary) FROM emp);\r\n				2. 子查询的结果是多行单列的：\r\n					* 子查询可以作为条件，使用运算符in来判断\r\n					-- 查询\'财务部\'和\'市场部\'所有的员工信息\r\n					SELECT id FROM dept WHERE NAME = \'财务部\' OR NAME = \'市场部\';\r\n					SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;\r\n					-- 子查询\r\n					SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = \'财务部\' OR NAME = \'市场部\');\r\n\r\n				3. 子查询的结果是多行多列的：\r\n					* 子查询可以作为一张虚拟表参与查询\r\n					-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息\r\n					-- 子查询\r\n					SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > \'2011-11-11\') t2\r\n					WHERE t1.id = t2.dept_id;\r\n					\r\n					-- 普通内连接\r\n					SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  \'2011-11-11\'\r\n\r\n		* 多表查询练习\r\n\r\n				-- 部门表\r\n				CREATE TABLE dept (\r\n				  id INT PRIMARY KEY PRIMARY KEY, -- 部门id\r\n				  dname VARCHAR(50), -- 部门名称\r\n				  loc VARCHAR(50) -- 部门所在地\r\n				);\r\n				\r\n				-- 添加4个部门\r\n				INSERT INTO dept(id,dname,loc) VALUES \r\n				(10,\'教研部\',\'北京\'),\r\n				(20,\'学工部\',\'上海\'),\r\n				(30,\'销售部\',\'广州\'),\r\n				(40,\'财务部\',\'深圳\');\r\n				\r\n				\r\n				\r\n				-- 职务表，职务名称，职务描述\r\n				CREATE TABLE job (\r\n				  id INT PRIMARY KEY,\r\n				  jname VARCHAR(20),\r\n				  description VARCHAR(50)\r\n				);\r\n				\r\n				-- 添加4个职务\r\n				INSERT INTO job (id, jname, description) VALUES\r\n				(1, \'董事长\', \'管理整个公司，接单\'),\r\n				(2, \'经理\', \'管理部门员工\'),\r\n				(3, \'销售员\', \'向客人推销产品\'),\r\n				(4, \'文员\', \'使用办公软件\');\r\n				\r\n				\r\n				\r\n				-- 员工表\r\n				CREATE TABLE emp (\r\n				  id INT PRIMARY KEY, -- 员工id\r\n				  ename VARCHAR(50), -- 员工姓名\r\n				  job_id INT, -- 职务id\r\n				  mgr INT , -- 上级领导\r\n				  joindate DATE, -- 入职日期\r\n				  salary DECIMAL(7,2), -- 工资\r\n				  bonus DECIMAL(7,2), -- 奖金\r\n				  dept_id INT, -- 所在部门编号\r\n				  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),\r\n				  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)\r\n				);\r\n				\r\n				-- 添加员工\r\n				INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES \r\n				(1001,\'孙悟空\',4,1004,\'2000-12-17\',\'8000.00\',NULL,20),\r\n				(1002,\'卢俊义\',3,1006,\'2001-02-20\',\'16000.00\',\'3000.00\',30),\r\n				(1003,\'林冲\',3,1006,\'2001-02-22\',\'12500.00\',\'5000.00\',30),\r\n				(1004,\'唐僧\',2,1009,\'2001-04-02\',\'29750.00\',NULL,20),\r\n				(1005,\'李逵\',4,1006,\'2001-09-28\',\'12500.00\',\'14000.00\',30),\r\n				(1006,\'宋江\',2,1009,\'2001-05-01\',\'28500.00\',NULL,30),\r\n				(1007,\'刘备\',2,1009,\'2001-09-01\',\'24500.00\',NULL,10),\r\n				(1008,\'猪八戒\',4,1004,\'2007-04-19\',\'30000.00\',NULL,20),\r\n				(1009,\'罗贯中\',1,NULL,\'2001-11-17\',\'50000.00\',NULL,10),\r\n				(1010,\'吴用\',3,1006,\'2001-09-08\',\'15000.00\',\'0.00\',30),\r\n				(1011,\'沙僧\',4,1004,\'2007-05-23\',\'11000.00\',NULL,20),\r\n				(1012,\'李逵\',4,1006,\'2001-12-03\',\'9500.00\',NULL,30),\r\n				(1013,\'小白龙\',4,1004,\'2001-12-03\',\'30000.00\',NULL,20),\r\n				(1014,\'关羽\',4,1007,\'2002-01-23\',\'13000.00\',NULL,10);\r\n				\r\n				\r\n				\r\n				-- 工资等级表\r\n				CREATE TABLE salarygrade (\r\n				  grade INT PRIMARY KEY,   -- 级别\r\n				  losalary INT,  -- 最低工资\r\n				  hisalary INT -- 最高工资\r\n				);\r\n				\r\n				-- 添加5个工资等级\r\n				INSERT INTO salarygrade(grade,losalary,hisalary) VALUES \r\n				(1,7000,12000),\r\n				(2,12010,14000),\r\n				(3,14010,20000),\r\n				(4,20010,30000),\r\n				(5,30010,99990);\r\n				\r\n				-- 需求：\r\n				\r\n				-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述\r\n				/*\r\n					分析：\r\n						1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表\r\n						2.查询条件 emp.job_id = job.id\r\n				\r\n				*/\r\n				SELECT \r\n					t1.`id`, -- 员工编号\r\n					t1.`ename`, -- 员工姓名\r\n					t1.`salary`,-- 工资\r\n					t2.`jname`, -- 职务名称\r\n					t2.`description` -- 职务描述\r\n				FROM \r\n					emp t1, job t2\r\n				WHERE \r\n					t1.`job_id` = t2.`id`;\r\n				\r\n				\r\n				\r\n				-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置\r\n				/*\r\n					分析：\r\n						1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept\r\n						2. 条件： emp.job_id = job.id and emp.dept_id = dept.id\r\n				*/\r\n				\r\n				SELECT \r\n					t1.`id`, -- 员工编号\r\n					t1.`ename`, -- 员工姓名\r\n					t1.`salary`,-- 工资\r\n					t2.`jname`, -- 职务名称\r\n					t2.`description`, -- 职务描述\r\n					t3.`dname`, -- 部门名称\r\n					t3.`loc` -- 部门位置\r\n				FROM \r\n					emp t1, job t2,dept t3\r\n				WHERE \r\n					t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;\r\n				   \r\n				-- 3.查询员工姓名，工资，工资等级\r\n				/*\r\n					分析：\r\n						1.员工姓名，工资 emp  工资等级 salarygrade\r\n						2.条件 emp.salary >= salarygrade.losalary and emp.salary <= salarygrade.hisalary\r\n							emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary\r\n				*/\r\n				SELECT \r\n					t1.ename ,\r\n					t1.`salary`,\r\n					t2.*\r\n				FROM emp t1, salarygrade t2\r\n				WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;\r\n				\r\n				\r\n				\r\n				-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级\r\n				/*\r\n					分析：\r\n						1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade\r\n						2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary\r\n							\r\n				*/\r\n				SELECT \r\n					t1.`ename`,\r\n					t1.`salary`,\r\n					t2.`jname`,\r\n					t2.`description`,\r\n					t3.`dname`,\r\n					t3.`loc`,\r\n					t4.`grade`\r\n				FROM \r\n					emp t1,job t2,dept t3,salarygrade t4\r\n				WHERE \r\n					t1.`job_id` = t2.`id` \r\n					AND t1.`dept_id` = t3.`id`\r\n					AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;\r\n				\r\n				\r\n				\r\n				-- 5.查询出部门编号、部门名称、部门位置、部门人数\r\n				\r\n				/*\r\n					分析：\r\n						1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表\r\n						2.使用分组查询。按照emp.dept_id完成分组，查询count(id)\r\n						3.使用子查询将第2步的查询结果和dept表进行关联查询\r\n						\r\n				*/\r\n				SELECT \r\n					t1.`id`,t1.`dname`,t1.`loc` , t2.total\r\n				FROM \r\n					dept t1,\r\n					(SELECT\r\n						dept_id,COUNT(id) total\r\n					FROM \r\n						emp\r\n					GROUP BY dept_id) t2\r\n				WHERE t1.`id` = t2.dept_id;\r\n				\r\n				\r\n				-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询\r\n				\r\n				/*\r\n					分析：\r\n						1.姓名 emp， 直接上级的姓名 emp\r\n							* emp表的id 和 mgr 是自关联\r\n						2.条件 emp.id = emp.mgr\r\n						3.查询左表的所有数据，和 交集数据\r\n							* 使用左外连接查询\r\n					\r\n				*/\r\n				/*\r\n				select\r\n					t1.ename,\r\n					t1.mgr,\r\n					t2.`id`,\r\n					t2.ename\r\n				from emp t1, emp t2\r\n				where t1.mgr = t2.`id`;\r\n				\r\n				*/\r\n				\r\n				SELECT \r\n					t1.ename,\r\n					t1.mgr,\r\n					t2.`id`,\r\n					t2.`ename`\r\n				FROM emp t1\r\n				LEFT JOIN emp t2\r\n				ON t1.`mgr` = t2.`id`;\r\n\r\n\r\n## 事务\r\n\r\n	1. 事务的基本介绍\r\n		1. 概念：\r\n			*  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。\r\n			\r\n		2. 操作：\r\n			1. 开启事务： start transaction;\r\n			2. 回滚：rollback;\r\n			3. 提交：commit;\r\n		3. 例子：\r\n			CREATE TABLE account (\r\n				id INT PRIMARY KEY AUTO_INCREMENT,\r\n				NAME VARCHAR(10),\r\n				balance DOUBLE\r\n			);\r\n			-- 添加数据\r\n			INSERT INTO account (NAME, balance) VALUES (\'zhangsan\', 1000), (\'lisi\', 1000);\r\n			\r\n			\r\n			SELECT * FROM account;\r\n			UPDATE account SET balance = 1000;\r\n			-- 张三给李四转账 500 元\r\n			\r\n			-- 0. 开启事务\r\n			START TRANSACTION;\r\n			-- 1. 张三账户 -500\r\n			\r\n			UPDATE account SET balance = balance - 500 WHERE NAME = \'zhangsan\';\r\n			-- 2. 李四账户 +500\r\n			-- 出错了...\r\n			UPDATE account SET balance = balance + 500 WHERE NAME = \'lisi\';\r\n			\r\n			-- 发现执行没有问题，提交事务\r\n			COMMIT;\r\n			\r\n			-- 发现出问题了，回滚事务\r\n			ROLLBACK;\r\n		4. MySQL数据库中事务默认自动提交\r\n			\r\n			* 事务提交的两种方式：\r\n				* 自动提交：\r\n					* mysql就是自动提交的\r\n					* 一条DML(增删改)语句会自动提交一次事务。\r\n				* 手动提交：\r\n					* Oracle 数据库默认是手动提交事务\r\n					* 需要先开启事务，再提交\r\n			* 修改事务的默认提交方式：\r\n				* 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交\r\n				* 修改默认提交方式： set @@autocommit = 0;\r\n\r\n\r\n	2. 事务的四大特征：\r\n		1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。\r\n		2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。\r\n		3. 隔离性：多个事务之间。相互独立。\r\n		4. 一致性：事务操作前后，数据总量不变\r\n	3. 事务的隔离级别（了解）\r\n		* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。\r\n		* 存在问题：\r\n			1. 脏读：一个事务，读取到另一个事务中没有提交的数据\r\n			2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。\r\n			3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。\r\n		* 隔离级别：\r\n			1. read uncommitted：读未提交\r\n				* 产生的问题：脏读、不可重复读、幻读\r\n			2. read committed：读已提交 （Oracle）\r\n				* 产生的问题：不可重复读、幻读\r\n			3. repeatable read：可重复读 （MySQL默认）\r\n				* 产生的问题：幻读\r\n			4. serializable：串行化\r\n				* 可以解决所有的问题\r\n\r\n			* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低\r\n			* 数据库查询隔离级别：\r\n				* select @@tx_isolation;\r\n			* 数据库设置隔离级别：\r\n				* set global transaction isolation level  级别字符串;\r\n\r\n		* 演示：\r\n			set global transaction isolation level read uncommitted;\r\n			start transaction;\r\n			-- 转账操作\r\n			update account set balance = balance - 500 where id = 1;\r\n			update account set balance = balance + 500 where id = 2;\r\n\r\n\r\n\r\n## DCL：\r\n	* SQL分类：\r\n		1. DDL：操作数据库和表\r\n		2. DML：增删改表中数据\r\n		3. DQL：查询表中数据\r\n		4. DCL：管理用户，授权\r\n\r\n	* DBA：数据库管理员\r\n\r\n	* DCL：管理用户，授权\r\n		1. 管理用户\r\n			1. 添加用户：\r\n				* 语法：CREATE USER \'用户名\'@\'主机名\' IDENTIFIED BY \'密码\';\r\n			2. 删除用户：\r\n				* 语法：DROP USER \'用户名\'@\'主机名\';\r\n			3. 修改用户密码：\r\n				\r\n				UPDATE USER SET PASSWORD = PASSWORD(\'新密码\') WHERE USER = \'用户名\';\r\n				UPDATE USER SET PASSWORD = PASSWORD(\'abc\') WHERE USER = \'lisi\';\r\n				\r\n				SET PASSWORD FOR \'用户名\'@\'主机名\' = PASSWORD(\'新密码\');\r\n				SET PASSWORD FOR \'root\'@\'localhost\' = PASSWORD(\'123\');\r\n\r\n				* mysql中忘记了root用户的密码？\r\n					1. cmd -- > net stop mysql 停止mysql服务\r\n						* 需要管理员运行该cmd\r\n\r\n					2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables\r\n					3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功\r\n					4. use mysql;\r\n					5. update user set password = password(\'你的新密码\') where user = \'root\';\r\n					6. 关闭两个窗口\r\n					7. 打开任务管理器，手动结束mysqld.exe 的进程\r\n					8. 启动mysql服务\r\n					9. 使用新密码登录。\r\n			4. 查询用户：\r\n				-- 1. 切换到mysql数据库\r\n				USE myql;\r\n				-- 2. 查询user表\r\n				SELECT * FROM USER;\r\n				\r\n				* 通配符： % 表示可以在任意主机使用用户登录数据库\r\n\r\n		2. 权限管理：\r\n			1. 查询权限：\r\n				-- 查询权限\r\n				SHOW GRANTS FOR \'用户名\'@\'主机名\';\r\n				SHOW GRANTS FOR \'lisi\'@\'%\';\r\n\r\n			2. 授予权限：\r\n				-- 授予权限\r\n				grant 权限列表 on 数据库名.表名 to \'用户名\'@\'主机名\';\r\n				-- 给张三用户授予所有权限，在任意数据库任意表上\r\n				\r\n				GRANT ALL ON *.* TO \'zhangsan\'@\'localhost\';\r\n			3. 撤销权限：\r\n				-- 撤销权限：\r\n				revoke 权限列表 on 数据库名.表名 from \'用户名\'@\'主机名\';\r\n				REVOKE UPDATE ON db3.`account` FROM \'lisi\'@\'%\';','2021-04-09 12:26:52',' 事务的基本介绍\r\n		1. 概念：\r\n			*  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。\r\n			\r\n		2. 操作：\r\n			1. 开启事务： start transaction;\r\n			2. 回滚：rollback;\r\n			3. 提交：commit...','https://z3.ax1x.com/2021/04/09/cUQOwq.jpg','','','','','mysql多表&事务笔记','2021-04-09 12:45:09',1,11,2,0),(19,'','','# JavaScript基础\r\n## JavaScript：\r\n	* 概念：	一门客户端脚本语言\r\n		* 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎\r\n		* 脚本语言：不需要编译，直接就可以被浏览器解析执行了\r\n\r\n	* 功能：\r\n		* 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。\r\n	\r\n	* JavaScript发展史：\r\n		1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--	，后来更名为：ScriptEase\r\n		2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript\r\n		3. 1996年，微软抄袭JavaScript开发出JScript语言\r\n		4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。\r\n\r\n		* JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)\r\n\r\n	* ECMAScript：客户端脚本语言的标准\r\n		1. 基本语法：\r\n			1. 与html结合方式\r\n				1. 内部JS：\r\n					* 定义<script>，标签体内容就是js代码\r\n				2. 外部JS：\r\n					* 定义<script>，通过src属性引入外部的js文件\r\n\r\n				* 注意：\r\n					1. <script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。\r\n					2. <script>可以定义多个。\r\n			2. 注释\r\n				1. 单行注释：//注释内容\r\n				2. 多行注释：/*注释内容*/\r\n			3. 数据类型：\r\n				1. 原始数据类型(基本数据类型)：\r\n					1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)\r\n					2. string：字符串。 字符串  \"abc\" \"a\" \'abc\'\r\n					3. boolean: true和false\r\n					4. null：一个对象为空的占位符\r\n					5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined\r\n					\r\n				2. 引用数据类型：对象\r\n				\r\n			4. 变量\r\n				* 变量：一小块存储数据的内存空间\r\n				* Java语言是强类型语言，而JavaScript是弱类型语言。\r\n					* 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据\r\n					* 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。\r\n				* 语法：\r\n					* var 变量名 = 初始化值;\r\n				\r\n				* typeof运算符：获取变量的类型。\r\n					* 注：null运算后得到的是object\r\n			5. 运算符\r\n				1. 一元运算符：只有一个运算数的运算符\r\n					++，-- ， +(正号)  \r\n					* ++ --: 自增(自减)\r\n						* ++(--) 在前，先自增(自减)，再运算\r\n						* ++(--) 在后，先运算，再自增(自减)\r\n					* +(-)：正负号\r\n				    * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换\r\n                        * 其他类型转number：\r\n                            * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）\r\n                            * boolean转number：true转为1，false转为0\r\n				2. 算数运算符\r\n					+ - * / % ...\r\n\r\n				3. 赋值运算符\r\n					= += -+....\r\n\r\n				4. 比较运算符\r\n					> < >= <= == ===(全等于)\r\n					* 比较方式\r\n	                  1. 类型相同：直接比较\r\n	                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。\r\n	                  2. 类型不同：先进行类型转换，再比较\r\n	                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false\r\n					\r\n\r\n				5. 逻辑运算符\r\n					&& || !\r\n					* 其他类型转boolean：\r\n	                   1. number：0或NaN为假，其他为真\r\n	                   2. string：除了空字符串(\"\")，其他都是true\r\n	                   3. null&undefined:都是false\r\n	                   4. 对象：所有对象都为true\r\n				\r\n				6. 三元运算符\r\n					? : 表达式\r\n					var a = 3;\r\n			        var b = 4;\r\n			\r\n			        var c = a > b ? 1:0;\r\n					* 语法：\r\n						* 表达式? 值1:值2;\r\n						* 判断表达式的值，如果是true则取值1，如果是false则取值2；\r\n				\r\n			6. 流程控制语句：\r\n				1. if...else...\r\n				2. switch:\r\n					* 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)\r\n						* switch(变量):\r\n							case 值:\r\n					* 在JS中,switch语句可以接受任意的原始数据类型\r\n				3. while\r\n				4. do...while\r\n				5. for\r\n			7. JS特殊语法：\r\n				1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)\r\n				2. 变量的定义使用var关键字，也可以不使用\r\n            		* 用： 定义的变量是局部变量\r\n	                * 不用：定义的变量是全局变量(不建议)\r\n\r\n			8. 练习：99乘法表\r\n			<!DOCTYPE html>\r\n			<html lang=\"en\">\r\n			<head>\r\n			    <meta charset=\"UTF-8\">\r\n			    <title>99乘法表</title>\r\n			    <style>\r\n			        td{\r\n			            border: 1px solid;\r\n			        }\r\n			\r\n			    </style>\r\n			\r\n			    <script>\r\n			\r\n			        document.write(\"<table  align=\'center\'>\");\r\n			\r\n			\r\n			        //1.完成基本的for循环嵌套，展示乘法表\r\n			        for (var i = 1; i <= 9 ; i++) {\r\n			            document.write(\"<tr>\");\r\n			            for (var j = 1; j <=i ; j++) {\r\n			                document.write(\"<td>\");\r\n			\r\n			                //输出  1 * 1 = 1\r\n			                document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&nbsp;&nbsp;&nbsp;\");\r\n			\r\n			                document.write(\"</td>\");\r\n			            }\r\n			            /*//输出换行\r\n			            document.write(\"<br>\");*/\r\n			\r\n			            document.write(\"</tr>\");\r\n			        }\r\n			\r\n			        //2.完成表格嵌套\r\n			        document.write(\"</table>\");\r\n			\r\n			    </script>\r\n			</head>\r\n			<body>\r\n			\r\n			</body>\r\n			</html>\r\n\r\n		2. 基本对象：\r\n			1. Function：函数(方法)对象\r\n                1. 创建：\r\n                    1. var fun = new Function(形式参数列表,方法体);  //忘掉吧\r\n                    2. \r\n	                    function 方法名称(形式参数列表){\r\n                            方法体\r\n                        }\r\n\r\n                    3. \r\n	                   var 方法名 = function(形式参数列表){\r\n                            方法体\r\n                       }\r\n                2. 方法：\r\n\r\n                3. 属性：\r\n                    length:代表形参的个数\r\n                4. 特点：\r\n                    1. 方法定义是，形参的类型不用写,返回值类型也不写。\r\n                    2. 方法是一个对象，如果定义名称相同的方法，会覆盖\r\n                    3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关\r\n                    4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数\r\n                5. 调用：\r\n                    方法名称(实际参数列表);\r\n			\r\n			2. Array:数组对象\r\n                1. 创建：\r\n                    1. var arr = new Array(元素列表);\r\n                    2. var arr = new Array(默认长度);\r\n                    3. var arr = [元素列表];\r\n                2. 方法\r\n                    join(参数):将数组中的元素按照指定的分隔符拼接为字符串\r\n                    push()	向数组的末尾添加一个或更多元素，并返回新的长度。\r\n                3. 属性\r\n                    length:数组的长度\r\n                4. 特点：\r\n                    1. JS中，数组元素的类型可变的。\r\n                    2. JS中，数组长度可变的。\r\n			3. Boolean\r\n			4. Date：日期对象\r\n                1. 创建：\r\n                    var date = new Date();\r\n\r\n                2. 方法：\r\n                    toLocaleString()：返回当前date对象对应的时间本地字符串格式\r\n                    getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差\r\n			5. Math：数学对象\r\n                1. 创建：\r\n                    * 特点：Math对象不用创建，直接使用。  Math.方法名();\r\n\r\n                2. 方法：\r\n                    random():返回 0 ~ 1 之间的随机数。 含0不含1\r\n                    ceil(x)：对数进行上舍入。\r\n                    floor(x)：对数进行下舍入。\r\n                    round(x)：把数四舍五入为最接近的整数。\r\n                3. 属性：\r\n                    PI\r\n			6. Number\r\n			7. String\r\n			8. RegExp：正则表达式对象\r\n				1. 正则表达式：定义字符串的组成规则。\r\n					1. 单个字符:[]\r\n						如： [a] [ab] [a-zA-Z0-9_]\r\n						* 特殊符号代表特殊含义的单个字符:\r\n							\\d:单个数字字符 [0-9]\r\n							\\w:单个单词字符[a-zA-Z0-9_]\r\n					2. 量词符号：\r\n						?：表示出现0次或1次\r\n						*：表示出现0次或多次\r\n						+：出现1次或多次\r\n						{m,n}:表示 m<= 数量 <= n\r\n							* m如果缺省： {,n}:最多n次\r\n							* n如果缺省：{m,} 最少m次\r\n					3. 开始结束符号\r\n						* ^:开始\r\n						* $:结束\r\n				2. 正则对象：\r\n					1. 创建\r\n						1. var reg = new RegExp(\"正则表达式\");\r\n						2. var reg = /正则表达式/;\r\n					2. 方法	\r\n						1. test(参数):验证指定的字符串是否符合正则定义的规范	\r\n			9. Global\r\n				1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();\r\n				2. 方法：\r\n				    encodeURI():url编码\r\n				    decodeURI():url解码\r\n\r\n				    encodeURIComponent():url编码,编码的字符更多\r\n				    decodeURIComponent():url解码\r\n\r\n				    parseInt():将字符串转为数字\r\n				        * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number\r\n				    isNaN():判断一个值是否是NaN\r\n				        * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false\r\n\r\n				    eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。\r\n                3. URL编码\r\n                   传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\r\n\r\n	* BOM\r\n\r\n	* DOM\r\n\r\n\r\n\r\n\r\n\r\n	','2021-04-09 12:29:42',' JavaScript：\r\n	* 概念：	一门客户端脚本语言\r\n		* 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎\r\n		* 脚本语言：不需要编译，直接就可以被浏览器解析执行了\r\n\r\n	* 功能：\r\n		* 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果...','https://z3.ax1x.com/2021/04/09/cUQae1.jpg','','','','','JavaScript基础笔记','2021-04-09 12:45:29',0,7,2,0),(20,'','','# JavaScript高级\r\n	1. JavaScript：\r\n		1. ECMAScript：\r\n		2. BOM：\r\n		3. DOM：\r\n			1. 事件\r\n\r\n## DOM简单学习：为了满足案例要求\r\n	* 功能：控制html文档的内容\r\n	* 获取页面标签(元素)对象：Element\r\n		* document.getElementById(\"id值\"):通过元素的id获取元素对象\r\n\r\n	* 操作Element对象：\r\n		1. 修改属性值：\r\n			1. 明确获取的对象是哪一个？\r\n			2. 查看API文档，找其中有哪些属性可以设置\r\n		2. 修改标签体内容：\r\n			* 属性：innerHTML\r\n			1. 获取元素对象\r\n			2. 使用innerHTML属性修改标签体内容\r\n\r\n## 事件简单学习\r\n	* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。\r\n		* 造句：  xxx被xxx,我就xxx\r\n			* 我方水晶被摧毁后，我就责备对友。\r\n			* 敌方水晶被摧毁后，我就夸奖自己。\r\n\r\n	* 如何绑定事件\r\n		1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码\r\n			1. 事件：onclick--- 单击事件\r\n\r\n		2. 通过js获取元素对象，指定事件属性，设置一个函数\r\n\r\n		* 代码：\r\n			<body>\r\n				<img id=\"light\" src=\"img/off.gif\"  onclick=\"fun();\">\r\n				<img id=\"light2\" src=\"img/off.gif\">\r\n				\r\n				<script>\r\n				    function fun(){\r\n				        alert(\'我被点了\');\r\n				        alert(\'我又被点了\');\r\n				    }\r\n				\r\n				    function fun2(){\r\n				        alert(\'咋老点我？\');\r\n				    }\r\n				\r\n				    //1.获取light2对象\r\n				    var light2 = document.getElementById(\"light2\");\r\n				    //2.绑定事件\r\n				    light2.onclick = fun2;\r\n				\r\n				\r\n				</script>\r\n			</body>\r\n	\r\n	* 案例1：电灯开关\r\n		<!DOCTYPE html>\r\n		<html lang=\"en\">\r\n		<head>\r\n		    <meta charset=\"UTF-8\">\r\n		    <title>电灯开关</title>\r\n		\r\n		</head>\r\n		<body>\r\n		\r\n		<img id=\"light\" src=\"img/off.gif\">\r\n		\r\n		<script>\r\n		    /*\r\n		        分析：\r\n		            1.获取图片对象\r\n		            2.绑定单击事件\r\n		            3.每次点击切换图片\r\n		                * 规则：\r\n		                    * 如果灯是开的 on,切换图片为 off\r\n		                    * 如果灯是关的 off,切换图片为 on\r\n		                * 使用标记flag来完成\r\n		\r\n		     */\r\n		\r\n		    //1.获取图片对象\r\n		    var light = document.getElementById(\"light\");\r\n		\r\n		    var flag = false;//代表灯是灭的。 off图片\r\n		\r\n		    //2.绑定单击事件\r\n		    light.onclick = function(){\r\n		        if(flag){//判断如果灯是开的，则灭掉\r\n		            light.src = \"img/off.gif\";\r\n		            flag = false;\r\n		\r\n		        }else{\r\n		            //如果灯是灭的，则打开\r\n		\r\n		            light.src = \"img/on.gif\";\r\n		            flag = true;\r\n		        }\r\n		\r\n		\r\n		    }\r\n		    \r\n		</script>\r\n		</body>\r\n		</html>\r\n\r\n\r\n# BOM:\r\n	1. 概念：Browser Object Model 浏览器对象模型\r\n		* 将浏览器的各个组成部分封装成对象。\r\n\r\n	2. 组成：\r\n		* Window：窗口对象\r\n		* Navigator：浏览器对象\r\n		* Screen：显示器屏幕对象\r\n		* History：历史记录对象\r\n		* Location：地址栏对象\r\n\r\n	3. Window：窗口对象\r\n	    1. 创建\r\n	    2. 方法\r\n	         1. 与弹出框有关的方法：\r\n	            alert()	显示带有一段消息和一个确认按钮的警告框。\r\n	            confirm()	显示带有一段消息以及确认按钮和取消按钮的对话框。\r\n	                * 如果用户点击确定按钮，则方法返回true\r\n	                * 如果用户点击取消按钮，则方法返回false\r\n	            prompt()	显示可提示用户输入的对话框。\r\n	                * 返回值：获取用户输入的值\r\n	         2. 与打开关闭有关的方法：\r\n	            close()	关闭浏览器窗口。\r\n	                * 谁调用我 ，我关谁\r\n	            open()	打开一个新的浏览器窗口\r\n	                * 返回新的Window对象\r\n	         3. 与定时器有关的方式\r\n	            setTimeout()	在指定的毫秒数后调用函数或计算表达式。\r\n	                * 参数：\r\n	                    1. js代码或者方法对象\r\n	                    2. 毫秒值\r\n	                * 返回值：唯一标识，用于取消定时器\r\n	            clearTimeout()	取消由 setTimeout() 方法设置的 timeout。\r\n	\r\n	            setInterval()	按照指定的周期（以毫秒计）来调用函数或计算表达式。\r\n	            clearInterval()	取消由 setInterval() 设置的 timeout。\r\n	\r\n	    3. 属性：\r\n	        1. 获取其他BOM对象：\r\n	            history\r\n	            location\r\n	            Navigator\r\n	            Screen:\r\n	        2. 获取DOM对象\r\n	            document\r\n	    4. 特点\r\n	        * Window对象不需要创建可以直接使用 window使用。 window.方法名();\r\n	        * window引用可以省略。  方法名();\r\n\r\n\r\n	4. Location：地址栏对象\r\n		1. 创建(获取)：\r\n			1. window.location\r\n			2. location\r\n\r\n		2. 方法：\r\n			* reload()	重新加载当前文档。刷新\r\n		3. 属性\r\n			* href	设置或返回完整的 URL。\r\n\r\n\r\n	5. History：历史记录对象\r\n        1. 创建(获取)：\r\n            1. window.history\r\n            2. history\r\n\r\n        2. 方法：\r\n            * back()	加载 history 列表中的前一个 URL。\r\n            * forward()	加载 history 列表中的下一个 URL。\r\n            * go(参数)	加载 history 列表中的某个具体页面。\r\n                * 参数：\r\n                    * 正数：前进几个历史记录\r\n                    * 负数：后退几个历史记录\r\n        3. 属性：\r\n            * length	返回当前窗口历史列表中的 URL 数量。\r\n\r\n\r\n\r\n\r\n## DOM：\r\n	* 概念： Document Object Model 文档对象模型\r\n		* 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作\r\n\r\n	* W3C DOM 标准被分为 3 个不同的部分：\r\n\r\n		* 核心 DOM - 针对任何结构化文档的标准模型\r\n			* Document：文档对象\r\n			* Element：元素对象\r\n			* Attribute：属性对象\r\n			* Text：文本对象\r\n			* Comment:注释对象\r\n\r\n			* Node：节点对象，其他5个的父对象\r\n		* XML DOM - 针对 XML 文档的标准模型\r\n		* HTML DOM - 针对 HTML 文档的标准模型\r\n\r\n\r\n\r\n\r\n\r\n	* 核心DOM模型：\r\n		* Document：文档对象\r\n			1. 创建(获取)：在html dom模型中可以使用window对象来获取\r\n				1. window.document\r\n				2. document\r\n			2. 方法：\r\n				1. 获取Element对象：\r\n					1. getElementById()	： 根据id属性值获取元素对象。id属性值一般唯一\r\n					2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组\r\n					3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组\r\n					4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组\r\n				2. 创建其他DOM对象：\r\n					createAttribute(name)\r\n                	createComment()\r\n                	createElement()\r\n                	createTextNode()\r\n			3. 属性\r\n		* Element：元素对象\r\n			1. 获取/创建：通过document来获取和创建\r\n			2. 方法：\r\n				1. removeAttribute()：删除属性\r\n				2. setAttribute()：设置属性\r\n		* Node：节点对象，其他5个的父对象\r\n			* 特点：所有dom对象都可以被认为是一个节点\r\n			* 方法：\r\n				* CRUD dom树：\r\n					* appendChild()：向节点的子节点列表的结尾添加新的子节点。\r\n					* removeChild()	：删除（并返回）当前节点的指定子节点。\r\n					* replaceChild()：用新节点替换一个子节点。\r\n			* 属性：\r\n				* parentNode 返回节点的父节点。\r\n\r\n\r\n	* HTML DOM\r\n		1. 标签体的设置和获取：innerHTML\r\n		2. 使用html元素对象的属性\r\n		3. 控制元素样式\r\n			1. 使用元素的style属性来设置\r\n				如：\r\n					 //修改样式方式1\r\n			        div1.style.border = \"1px solid red\";\r\n			        div1.style.width = \"200px\";\r\n			        //font-size--> fontSize\r\n			        div1.style.fontSize = \"20px\";\r\n			2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。\r\n\r\n\r\n## 事件监听机制：\r\n	* 概念：某些组件被执行了某些操作后，触发某些代码的执行。	\r\n		* 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了\r\n		* 事件源：组件。如： 按钮 文本输入框...\r\n		* 监听器：代码。\r\n		* 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。\r\n\r\n\r\n	* 常见的事件：\r\n		1. 点击事件：\r\n			1. onclick：单击事件\r\n			2. ondblclick：双击事件\r\n		2. 焦点事件\r\n			1. onblur：失去焦点\r\n			2. onfocus:元素获得焦点。\r\n\r\n		3. 加载事件：\r\n			1. onload：一张页面或一幅图像完成加载。\r\n\r\n		4. 鼠标事件：\r\n			1. onmousedown	鼠标按钮被按下。\r\n			2. onmouseup	鼠标按键被松开。\r\n			3. onmousemove	鼠标被移动。\r\n			4. onmouseover	鼠标移到某元素之上。\r\n			5. onmouseout	鼠标从某元素移开。\r\n			\r\n			\r\n		5. 键盘事件：\r\n			1. onkeydown	某个键盘按键被按下。	\r\n			2. onkeyup		某个键盘按键被松开。\r\n			3. onkeypress	某个键盘按键被按下并松开。\r\n\r\n		6. 选择和改变\r\n			1. onchange	域的内容被改变。\r\n			2. onselect	文本被选中。\r\n\r\n		7. 表单事件：\r\n			1. onsubmit	确认按钮被点击。\r\n			2. onreset	重置按钮被点击。','2021-04-09 12:31:27','操作Element对象：\r\n		1. 修改属性值：\r\n			1. 明确获取的对象是哪一个？\r\n			2. 查看API文档，找其中有哪些属性可以设置\r\n		2. 修改标签体内容：\r\n			* 属性：innerHTML\r\n			1. 获取元素对象\r\n			2. 使用innerHTML属性修改标签体内容...\r\n\r\n## 事件简单学习\r\n	* 功能： 某些组件被执行了某些操作后，触发某些代码的执行...','https://z3.ax1x.com/2021/04/09/cUMQ8e.jpg','原创','','\0','','JavaScript高级笔记','2021-04-09 12:45:33',0,7,2,0),(21,'','','# XML\r\n	1. XML\r\n		1. 概念\r\n		2. 语法\r\n		3. 解析\r\n\r\n\r\n## XML：\r\n	1. 概念：Extensible Markup Language 可扩展标记语言\r\n		* 可扩展：标签都是自定义的。 <user>  <student>\r\n\r\n		* 功能\r\n			* 存储数据\r\n				1. 配置文件\r\n				2. 在网络中传输\r\n		* xml与html的区别\r\n			1. xml标签都是自定义的，html标签是预定义。\r\n			2. xml的语法严格，html语法松散\r\n			3. xml是存储数据的，html是展示数据\r\n\r\n		* w3c:万维网联盟\r\n\r\n	2. 语法：\r\n		* 基本语法：\r\n			1. xml文档的后缀名 .xml\r\n			2. xml第一行必须定义为文档声明\r\n			3. xml文档中有且仅有一个根标签\r\n			4. 属性值必须使用引号(单双都可)引起来\r\n			5. 标签必须正确关闭\r\n			6. xml标签名称区分大小写\r\n		* 快速入门：\r\n			<?xml version=\'1.0\' ?>\r\n			<users>\r\n				<user id=\'1\'>\r\n					<name>zhangsan</name>\r\n					<age>23</age>\r\n					<gender>male</gender>\r\n					<br/>\r\n				</user>\r\n				\r\n				<user id=\'2\'>\r\n					<name>lisi</name>\r\n					<age>24</age>\r\n					<gender>female</gender>\r\n				</user>\r\n			</users>\r\n			\r\n		* 组成部分：\r\n			1. 文档声明\r\n				1. 格式：<?xml 属性列表 ?>\r\n				2. 属性列表：\r\n					* version：版本号，必须的属性\r\n					* encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1\r\n					* standalone：是否独立\r\n						* 取值：\r\n							* yes：不依赖其他文件\r\n							* no：依赖其他文件\r\n			2. 指令(了解)：结合css的\r\n				* <?xml-stylesheet type=\"text/css\" href=\"a.css\" ?>\r\n			3. 标签：标签名称自定义的\r\n				* 规则：\r\n					* 名称可以包含字母、数字以及其他的字符 \r\n					* 名称不能以数字或者标点符号开始 \r\n					* 名称不能以字母 xml（或者 XML、Xml 等等）开始 \r\n					* 名称不能包含空格 \r\n\r\n			4. 属性：\r\n				id属性值唯一\r\n			5. 文本：\r\n				* CDATA区：在该区域中的数据会被原样展示\r\n					* 格式：  <![CDATA[ 数据 ]]>\r\n\r\n	\r\n		* 约束：规定xml文档的书写规则\r\n			* 作为框架的使用者(程序员)：\r\n				1. 能够在xml中引入约束文档\r\n				2. 能够简单的读懂约束文档\r\n			\r\n			* 分类：\r\n				1. DTD:一种简单的约束技术\r\n				2. Schema:一种复杂的约束技术\r\n\r\n\r\n			* DTD：\r\n				* 引入dtd文档到xml文档中\r\n					* 内部dtd：将约束规则定义在xml文档中\r\n					* 外部dtd：将约束的规则定义在外部的dtd文件中\r\n						* 本地：<!DOCTYPE 根标签名 SYSTEM \"dtd文件的位置\">\r\n						* 网络：<!DOCTYPE 根标签名 PUBLIC \"dtd文件名字\" \"dtd文件的位置URL\">\r\n\r\n\r\n			* Schema:\r\n				* 引入：\r\n					1.填写xml文档的根元素\r\n					2.引入xsi前缀.  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n					3.引入xsd文件命名空间.  xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\"\r\n					4.为每一个xsd约束声明一个前缀,作为标识  xmlns=\"http://www.itcast.cn/xml\" \r\n\r\n				<students   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n					xmlns=\"http://www.itcast.cn/xml\"\r\n					xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\">\r\n	\r\n	\r\n\r\n	3. 解析：操作xml文档，将文档中的数据读取到内存中\r\n		* 操作xml文档\r\n			1. 解析(读取)：将文档中的数据读取到内存中\r\n			2. 写入：将内存中的数据保存到xml文档中。持久化的存储\r\n\r\n		* 解析xml的方式：\r\n			1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树\r\n				* 优点：操作方便，可以对文档进行CRUD的所有操作\r\n				* 缺点：占内存\r\n			2. SAX：逐行读取，基于事件驱动的。\r\n				* 优点：不占内存。\r\n				* 缺点：只能读取，不能增删改\r\n\r\n\r\n		\r\n		* xml常见的解析器：\r\n			1. JAXP：sun公司提供的解析器，支持dom和sax两种思想\r\n			2. DOM4J：一款非常优秀的解析器\r\n			3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\r\n			4. PULL：Android操作系统内置的解析器，sax方式的。\r\n\r\n\r\n		* Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\r\n			* 快速入门：\r\n				* 步骤：\r\n					1. 导入jar包\r\n					2. 获取Document对象\r\n					3. 获取对应的标签Element对象\r\n					4. 获取数据\r\n\r\n			* 代码：\r\n				 //2.1获取student.xml的path\r\n		        String path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath();\r\n		        //2.2解析xml文档，加载文档进内存，获取dom树--->Document\r\n		        Document document = Jsoup.parse(new File(path), \"utf-8\");\r\n		        //3.获取元素对象 Element\r\n		        Elements elements = document.getElementsByTag(\"name\");\r\n		\r\n		        System.out.println(elements.size());\r\n		        //3.1获取第一个name的Element对象\r\n		        Element element = elements.get(0);\r\n		        //3.2获取数据\r\n		        String name = element.text();\r\n		        System.out.println(name);\r\n\r\n		* 对象的使用：\r\n			1. Jsoup：工具类，可以解析html或xml文档，返回Document\r\n				* parse：解析html或xml文档，返回Document\r\n					* parse​(File in, String charsetName)：解析xml或html文件的。\r\n					* parse​(String html)：解析xml或html字符串\r\n					* parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象\r\n			2. Document：文档对象。代表内存中的dom树\r\n				* 获取Element对象\r\n					* getElementById​(String id)：根据id属性值获取唯一的element对象\r\n					* getElementsByTag​(String tagName)：根据标签名称获取元素对象集合\r\n					* getElementsByAttribute​(String key)：根据属性名称获取元素对象集合\r\n					* getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合\r\n			3. Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用\r\n			4. Element：元素对象\r\n				1. 获取子元素对象\r\n					* getElementById​(String id)：根据id属性值获取唯一的element对象\r\n					* getElementsByTag​(String tagName)：根据标签名称获取元素对象集合\r\n					* getElementsByAttribute​(String key)：根据属性名称获取元素对象集合\r\n					* getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合\r\n\r\n				2. 获取属性值\r\n					* String attr(String key)：根据属性名称获取属性值\r\n				3. 获取文本内容\r\n					* String text():获取文本内容\r\n					* String html():获取标签体的所有内容(包括字标签的字符串内容)\r\n			5. Node：节点对象\r\n				* 是Document和Element的父类\r\n\r\n			\r\n		* 快捷查询方式：\r\n			1. selector:选择器\r\n				* 使用的方法：Elements	select​(String cssQuery)\r\n					* 语法：参考Selector类中定义的语法\r\n			2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言\r\n				* 使用Jsoup的Xpath需要额外导入jar包。\r\n				* 查询w3cshool参考手册，使用xpath的语法完成查询\r\n				* 代码：\r\n					//1.获取student.xml的path\r\n			        String path = JsoupDemo6.class.getClassLoader().getResource(\"student.xml\").getPath();\r\n			        //2.获取Document对象\r\n			        Document document = Jsoup.parse(new File(path), \"utf-8\");\r\n			\r\n			        //3.根据document对象，创建JXDocument对象\r\n			        JXDocument jxDocument = new JXDocument(document);\r\n			\r\n			        //4.结合xpath语法查询\r\n			        //4.1查询所有student标签\r\n			        List<JXNode> jxNodes = jxDocument.selN(\"//student\");\r\n			        for (JXNode jxNode : jxNodes) {\r\n			            System.out.println(jxNode);\r\n			        }\r\n			\r\n			        System.out.println(\"--------------------\");\r\n			\r\n			        //4.2查询所有student标签下的name标签\r\n			        List<JXNode> jxNodes2 = jxDocument.selN(\"//student/name\");\r\n			        for (JXNode jxNode : jxNodes2) {\r\n			            System.out.println(jxNode);\r\n			        }\r\n			\r\n			        System.out.println(\"--------------------\");\r\n			\r\n			        //4.3查询student标签下带有id属性的name标签\r\n			        List<JXNode> jxNodes3 = jxDocument.selN(\"//student/name[@id]\");\r\n			        for (JXNode jxNode : jxNodes3) {\r\n			            System.out.println(jxNode);\r\n			        }\r\n			        System.out.println(\"--------------------\");\r\n			        //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast\r\n			\r\n			        List<JXNode> jxNodes4 = jxDocument.selN(\"//student/name[@id=\'itcast\']\");\r\n			        for (JXNode jxNode : jxNodes4) {\r\n			            System.out.println(jxNode);\r\n			        }','2021-04-09 12:33:01',' XML：\r\n	1. 概念：Extensible Markup Language 可扩展标记语言\r\n		* 可扩展：标签都是自定义的。 <user>  <student>\r\n\r\n		* 功能\r\n			* 存储数据\r\n				1. 配置文件\r\n				2. 在网络中传输\r\n		* xml与html的区别\r\n			1. xml标签都是自定义的，html标签是预定义。\r\n			2. xml的语法严格，html语法松散...','https://z3.ax1x.com/2021/04/09/cUMBvj.gif','','','\0','','XML笔记','2021-04-09 12:45:14',1,12,2,0);

/*Table structure for table `t_comment` */

DROP TABLE IF EXISTS `t_comment`;

CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `blog_id` bigint(20) DEFAULT NULL,
  `parent_comment_id` bigint(20) DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_comment` */

/*Table structure for table `t_friend` */

DROP TABLE IF EXISTS `t_friend`;

CREATE TABLE `t_friend` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `blogaddress` varchar(255) NOT NULL,
  `blogname` varchar(255) NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `pictureaddress` varchar(255) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_friend` */

insert  into `t_friend`(`id`,`blogaddress`,`blogname`,`create_time`,`pictureaddress`) values (5,'http://www.qingfenginn.top','清峰の小栈','2021-04-05 14:21:08','http://www.qingfenginn.top/images/me.jpg');

/*Table structure for table `t_message` */

DROP TABLE IF EXISTS `t_message`;

CREATE TABLE `t_message` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `parent_message_id` bigint(20) DEFAULT NULL,
  `admin_message` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_message` */

insert  into `t_message`(`id`,`nickname`,`email`,`content`,`avatar`,`create_time`,`parent_message_id`,`admin_message`) values (22,'刘雨声','1193616112@qq.com','欢迎大家来到我的‘雨声’小栈.','../images/me.jpg','2021-04-09 12:48:03',-1,'');

/*Table structure for table `t_picture` */

DROP TABLE IF EXISTS `t_picture`;

CREATE TABLE `t_picture` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `pictureaddress` varchar(255) DEFAULT NULL,
  `picturedescription` varchar(255) DEFAULT NULL,
  `picturename` varchar(255) DEFAULT NULL,
  `picturetime` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_picture` */

insert  into `t_picture`(`id`,`pictureaddress`,`picturedescription`,`picturename`,`picturetime`) values (8,'https://note.youdao.com/yws/api/personal/file/D114AABB679F4D82BEF5BF3E41F199BA?method=download&shareKey=b862b7ceaf0c9447894364a8631d7ba8','这是一个图片！','自拍风景','2020年10月23日 18:57 贵州省-六盘水'),(13,'https://z3.ax1x.com/2021/04/09/cUlPX9.jpg','大海无量...','大海无量','2021年4月8日 18:57 四川省-宜宾市'),(14,'https://z3.ax1x.com/2021/04/09/cUm57T.jpg','改貌站','集装箱站','2019年6月24日 05:34 贵州省-贵阳市'),(15,'https://z3.ax1x.com/2021/04/09/cUMrKs.jpg','网图','网图','2021年4月9日 21:229 四川省-宜宾市');

/*Table structure for table `t_type` */

DROP TABLE IF EXISTS `t_type`;

CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_type` */

insert  into `t_type`(`id`,`name`) values (4,'java'),(6,'html'),(7,'javascript'),(8,'css'),(9,'心灵鸡汤'),(10,'spring'),(11,'数据库'),(12,'xml');

/*Table structure for table `t_user` */

DROP TABLE IF EXISTS `t_user`;

CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

/*Data for the table `t_user` */

insert  into `t_user`(`id`,`avatar`,`create_time`,`email`,`nickname`,`password`,`type`,`update_time`,`username`) values (2,'../images/me.jpg',NULL,NULL,'刘雨声','e10adc3949ba59abbe56e057f20f883e',NULL,NULL,'lys');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
